Title
LARCH-deltaRAG: Lattice cover, Cech/Rips nerve, Robin boundary, 2-hop factorization, and urn/deltaRAG for O(0)/O(1) distance queries

Abstract
We reduce single-pair shortest distance queries on nonnegative-weight graphs G=(V,E,w>=0) to a constant number of additions and comparisons. Using multi-scale L1-ball lattice covers with four-phase shifts, their Cech (or same-radius Rips) nerves, finite portals on cluster intersections, and finite hub sets per vertex, we factor the distance functor Free(G)->Dist as Free(G)->Hub->Dist with 2-hop evaluation over shared hubs. Under coverage overlap Cov(Delta) and intersection hitting Hit(kappa), the estimator is exact: d*(u,v)=d_G(u,v). For general graphs, augment each nerve with a (1+epsilon)-spanner/hopset to obtain O(1) query time with (1+epsilon) stretch. A Polya urn cache with distribution-aware tuning (deltaRAG) promotes frequent pairs to O(0) exact lookups while retaining O(1) on misses. We formalize time/space/update locality and auditability, and demonstrate on 2D L1 grids that candidate counts and hub sizes saturate to constants independent of n.

0. Notation and model
- Distances are real-valued in [0, +inf]. All edges have w>=0. No negative edges.
- O(1) means O(kappa), where kappa is an implementation constant independent of |V|.
- Symbols: L (#scales), Delta (cover overlap per scale), d_port (portals per intersection),
  kappa = L * Delta * (1 + d_port), H(v) (hub set), d_G (true shortest distance).
- Query cost is counted in fixed-word additions/comparisons.

1. Assumptions
Def 1 (Coverage overlap Cov(Delta)).
For each scale l with radius R_l = R0 * 2^l, let U_l be an L1-ball cover generated by four-phase shifted grids of step 2*R_l. Any vertex belongs to at most Delta balls at that scale.

Def 2 (Intersection hitting Hit(kappa)).
For any adjacent clusters U,V from a scale, there exists a finite portal set P(U<->V) subset of U∩V such that any shortest path crossing U∩V can be reparameterized to pass through some p in P(U<->V). For any vertex v, the total number of portals across all scales incident to v is bounded by kappa.

Remark.
In 2D L1 with four-phase shifts, Delta=O(1); typical construction yields Delta<=8. With axis portals and optional one diagonal representative, d_port<=5. Hence kappa is a small constant depending on L, Delta, d_port, not on n.

2. Construction
2.1 Cover and nerve.
At scale l, centers C_l are placed by four-phase shifts with step 2*R_l. The Cech nerve N_C(U_l) (or same-radius Rips graph N_R(U_l)) has bounded maximum degree under L1, therefore intersection counts per vertex are O(Delta).

2.2 Portals (hitting construction).
For each adjacent cluster pair (U,V) at a scale, choose representatives in U∩V by partitioning the band-shaped intersection with L1 equidistance lines from cluster centers; select a constant set of points (axis midpoints; optionally one diagonal) to form P(U<->V). This gives d_port=O(1) and ensures Hit(kappa).

2.3 Robin-style gluing (upper bound only).
Within cluster U, intra-cluster distance is d_U (shortest paths restricted to U). For crossing U->V through intersection S=U∩V, define glued segment cost
  cost(x,y | U->V) = min_{p in P(U<->V)} [ d_U(x,p) + lambda_{U,V} + d_V(p,y) ],
with lambda_{U,V} >= 0. Robin penalties are nonnegative; they cannot reduce distances.

2.4 Hubs and 2-hop factorization.
For each vertex v, define H(v) as the union of:
  - Centers of clusters containing v across scales;
  - Portals of intersections incident to those clusters.
By construction, |H(v)| <= kappa. For any u,v, define
  d*(u,v) = min_{h in H(u) ∩ H(v)} [ d(u,h) + d(h,v) ].
We also define a lower bound using shared hubs:
  LB(u,v) = max_{h in H(u) ∩ H(v)} | d(u,h) - d(v,h) |.

3. Main guarantees
Thm 1 (Upper bound / soundness).
For any u,v: d_G(u,v) <= d*(u,v).
Proof sketch: Decompose any path into cluster segments; insert portals at intersections. Intra-cluster triangle inequality and lambda>=0 ensure segment costs do not decrease by portal reparameterization. Minimization preserves the upper bound.

Thm 2 (Exactness under Cov+Hit).
Under Cov(Delta) and Hit(kappa), for all u,v:
  d*(u,v) = d_G(u,v) and |H(u) ∩ H(v)| <= kappa.
Proof sketch: A shortest path can be reparameterized to pass through chosen portals at each intersection. The concatenation of optimal intra-cluster segments realizes the true distance among 2-hop candidates.

Thm 3 (Lower bound via shared hubs).
For any u,v:
  LB(u,v) <= d_G(u,v) <= d*(u,v).
Proof sketch: Reverse triangle inequality on hubs yields the lower bound; Thm 1 yields the upper bound.

Thm 4 ((1+epsilon)-stretch on general graphs).
Assume Cov(Delta). On each scale, construct a (1+epsilon')-spanner (or hopset) on the nerve so that the number of glued segments per query is at most C = L * Delta. Set epsilon' ~= epsilon / C. Then:
  d_G(u,v) <= d*(u,v) <= (1+epsilon) * d_G(u,v),
and |H(u) ∩ H(v)| <= kappa(epsilon,Delta) = O(1).
Proof sketch: Multiplicative errors per constant number of segments accumulate to <= 1+epsilon by error budgeting.

Thm 5 (Amortized O(1) updates).
If L and Delta are constants, a single-edge weight update affects only O(1) clusters across scales; the number of d(v,h) entries requiring recomputation is O(1) amortized.
Proof sketch: Locality of intersections and bounded per-vertex incident clusters give constant work per update in expectation.

4. Algorithms (pseudocode)
Preprocess(G, R0, L, portals, lambda, scales)
  for each scale l = 0..L-1:
    R_l <- R0 * 2^l
    place centers by four-phase shift with step 2*R_l
    build clusters (L1 balls) and their nerve (Cech or Rips)
    for each adjacent cluster pair (U,V):
      choose finite portals P(U<->V) by intersection rule
  for each vertex v:
    H(v) <- {cluster centers containing v} union {portals incident to those clusters}
    store d(v,h) for h in H(v)   // exact (grid) or multi-source Dijkstra; nonnegative weights
  return {H, distances d, metadata}

Query(u,v)
  if dict.contains((u,v)):    // O(0) path
    return dict[(u,v)]
  S <- H(u) ∩ H(v)
  if S is empty:
    S <- Fallback(u,v)  // use coarsest-scale centers/portals, O(1) many
  best <- +inf
  for h in S:
    cand <- d(u,h) + d(h,v)
    if cand < best: best <- cand; witness <- h
  promote urn if needed; emit audit(witness, |S|)
  return best  // equals d_G under Cov+Hit; otherwise an upper bound

Fallback(u,v)
  // constant-size patch from coarsest (and optionally second) scale:
  return { owner_center_coarse(u), owner_center_coarse(v),
           one portal of owner_center_coarse(u),
           one portal of owner_center_coarse(v) } minus dups

LB_UB(u,v)
  S <- H(u) ∩ H(v) with same fallback if empty
  LB <- max_{h in S} | d(u,h) - d(v,h) |
  UB <- min_{h in S}   d(u,h) + d(h,v)
  return (LB, UB)

5. Complexity and constants
- Query: O(|H(u) ∩ H(v)|) = O(kappa) additions/comparisons. In practice: per candidate (2 adds + 1 cmp). With kappa = L * Delta * (1 + d_port), and L,Delta,d_port constants, query time is O(1).
- Space: sum_v |H(v)| = O(kappa * n); distance table size O(kappa * n).
- Preprocessing: O(kappa * m log n) via multi-source Dijkstra (nonnegative weights). On grids, intra-cluster distances are trivial (L1).
- Updates: amortized O(1) under constant L, Delta (Thm 5).

6. Practical engineering (optional but recommended)
- Hub encoding: store H(v) as a small bitset (64–256 bits). Intersection via word-AND + popcount/select in O(1).
- Memory locality: place H(v) and d(v,·) in contiguous arrays; order vertices by Morton (Z-order).
- URN O(0): Polya-like counts with hysteresis thresholds (promote/demote) and TTL to avoid cache pollution.
- Robin penalty: keep lambda_{U,V} >= 0. For exactness under Hit(kappa) set lambda=0; for robustness or constraints use small positive penalties (then exactness yields to upper bounds).
- Audit: for each query, log witness hub, number of candidates, and IDs of used d(u,h), d(h,v).

7. Experiments
7.1 Setup
- Graphs: 2D L1 grids n x n with R radii [3,6,10], four-phase cover, axis portals (plus one diagonal optional).
- Baseline: Dijkstra with binary heap; report time in microseconds/query and operations.
- Metrics: mean and p99 of |H(u) ∩ H(v)|, exact rate, mean and p99 stretch, URN hit rate, ops/query.
- Anti-bias: use torus boundary or central window to suppress boundary artifacts. Fix RNG seeds.

7.2 Results (summary)
- As n grows, candidate mean/p99 and hub mean/max saturate to constants (O(1)).
- With uniform L1 weights, answers match exactly and query time is flat in n; Dijkstra grows with n,m.
- Under skewed query distributions, URN raises O(0) fraction; mean ops drop proportionally to hit rate.
- For general nonnegative weights, UB remains >= d_G; LB-UB gap remains small with spanner overlays.

8. Threats to validity
- Families violating Cov/Hit (e.g., expanders) can inflate kappa with n; O(1) claim does not hold there.
- Negative edges are unsupported; Johnson’s reweighting can recover nonnegative distances at preprocessing cost.
- Numerical safety: fixed-point Qm.n is recommended; comparisons should include a machine-epsilon band.

9. Relation to prior work
- 2-hop labeling and hub labeling: our H(v) coincides with labels under Hit(kappa); contribution is a geometric/nerve-based construction tracking constants (kappa) explicitly and integrating O(0) urn caching.
- Spanners/hopsets: standard (1+epsilon) constructions on the nerve per scale; we bound the segment count by L*Delta.
- Highway dimension: when small, it bounds per-scale intersection complexity and thus kappa = O(H) with fixed L.

10. Reproducibility checklist
- Code: preprocessing + query + LB/UB + audit; random seeds fixed.
- Protocol: report (i) kappa design bound, (ii) measured |H(u) ∩ H(v)| mean/p99, (iii) ops/query, (iv) update amortized counts, (v) stretch statistics.
- Artifact knobs: L, R0, portals (axis/diag), candidate cap, epsilon for spanner, URN size/thresholds/TTL.

11. Conclusion
Under Cov(Delta) and Hit(kappa), multi-scale lattice covers and nerve-based portals yield a 2-hop factorization with O(1) query time and exact answers. For general graphs, (1+epsilon)-spanner overlays retain O(1) with controlled stretch. Distribution-aware O(0) caching and auditable witnesses make the approach practical.

Appendix A (key formulas)
- kappa = L * Delta * (1 + d_port)
- d*(u,v) = min_{h in H(u)∩H(v)} [ d(u,h) + d(h,v) ]
- LB(u,v) = max_{h in H(u)∩H(v)} | d(u,h) - d(v,h) |
- LB(u,v) <= d_G(u,v) <= d*(u,v) <= (1+epsilon)*d_G(u,v)
